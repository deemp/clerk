\chapter{Evaluation and Discussion}
\label{chap:eval}

This chapter analyzes the research results.

\Cref{eval:findings} presents the main findings that are connected with the research purpose.
\Cref{eval:finding-results} interprets how the research results support these findings.
\Cref{eval:previous-research} contrasts my findings with the results of the past researches.
\Cref{eval:discrepancies} explains the discrepancies between my results and findings.
\Cref{eval:limitations} describes the limitations of my research.
\Cref{eval:unexpected} lists the unexpected findings.
\Cref{eval:outer-applications} suggests the possible applications of my research findings.

\section{Key findings}
\label{eval:findings}


The main finding is that it is possible to build a Haskell eDSL as a library that allows for declarative spreadsheet construction.
A user specifies the connections between the spreadsheet elements, and the library functions produce the elements layout automatically.
Despite being simple, the language requires the knowledge of Haskell at least at the beginner level.
That is why, the target audience of the language is Haskell programmers.
They are expected to generate the spreadsheets and pass these spreadsheets to non-programmers.

Another finding is that such an eDSL provides the means to construct statically typed formulas.
This feature allows for typechecking the formula expressions at compile time.
Such checks prevent runtime errors, such as invalid formula arguments, in spreadsheet applications.

The third finding is that it is possible to use the existing Haskell features in the programs written in the new eDSL.
First, formulas can be curried, composed, and applied to ranges of values and cell references.
Second, algebraic data types can be used to model the value domains.
Third, the \texttt{do-notation} works because the eDSL has a monadic interface.

\section{Results and findings}
\label{eval:finding-results}

First, the result of my research is the \texttt{clerk} Haskell package.
It is publicly available on GitHub \cite{danko_clerk_2023} and Hackage \cite{hackage_clerk_2023}.
Haskell programmers may discover the package there, read through the examples from the package description and use \texttt{clerk} in their programs.
The examples are based on simple problems and demonstrate most features of the eDSL.

Second, the type checking of formulas works at compile time.
A user first specifies the formula signature - a name and the types of arguments.
Later, the user can apply a formula to arguments.

Third, the examples from the package description demonstrate how to apply certain Haskell features to write type-safe monadic code using \texttt{clerk}.

\section{Previous research}
\label{eval:previous-research}

Currently, the major spreadsheet applications provide limited tools for declarative type-safe construction of spreadsheets.

\subsection{User-defined data types}
\label{subsec:user-defined-data-types}
Firstly, Microsoft Excel provides creation of user-defined data types \cite{excel_custom_types}.
A user may group the columns of values into records that represent user-defined types.
Additionally, they may use a user-defined data type as a type of a field of another user-defined data type.

In contrast, \texttt{clerk} allows to type-safely group values into Haskell records.
This approach allows for building type-safe composite records before importing them into a spreadsheet application.

\subsection{User-defined functions}

Microsoft Excel introduced the \texttt{LAMBDA} function \cite{excel_lambda} that allows for user-defined functions.
Google Sheets also provides the \texttt{LAMBDA} function \cite{sheets_lambda} that should immediately be applied to a value.
Thus, in this section, I focus on the \texttt{LAMBDA} function from Microsoft Excel.

First, the \texttt{LAMBDA} function can be recorded and shared between spreadsheets.
Second, this function allows for recursion and usage of other functions, including user-defined ones.
Third, user-defined functions are dynamically-typed.
The argument types can be specified as comments to a recorded user-defined function.

In comparison to \texttt{LAMBDA}, \texttt{clerk} allows a user to declare functions in Haskell.
First, these functions can be imported into other Haskell modules or programs.
Second, these functions may represent compositions of functions from the target spreadsheet system, including user-defined ones.
Third, these functions are statically typed. Their arguments may be documented using Haddock.

\subsection{Declarative layout}

Currently, Microsoft Excel has support for automatic layout of data upon importing it \cite{excel_custom_types}.
However, layout customization still should be done manually.

The \texttt{poi} library for Python can write spreadsheets based on user data \cite{wang_poi_nodate}.
The library seems to not allow to specify the connections between new elements and previously built elements.

Such functionality, on the other hand, is present in the Kotlin library Geschikt \cite{noauthor_sikrinickgeshikt_nodate}.
The library provides a declarative API to building Google Sheets.
A user may create an cell object and then access its reference in the expressions that follow.
The downside is that there seems to be no way to use a reference outside of a parent element.

In \texttt{clerk}, it is possible to get a reference to a specific cell.
It is the user's responsibility to return that reference from the function where the cell is created.
The cell references can be

\section{Discrepancies}
\label{eval:discrepancies}

\section{Limitations}
\label{eval:limitations}

First of all, currently, the eDSL is not usable by non-programmers.
Perhaps the implementation of a graphical user interface to the eDSL may solve this problem.

Next, another problem is that the library generates spreadsheets using the limited number of formatting tools provided by the underlying \texttt{xlsx} library.
Thus, if a user edits a generated part of a spreadsheet, these edits will be removed upon the next spreadsheet generation.
This limitation can be overcome by copying just the data from the generated parts into new sheets and applying formatting there.

\section{Unexpected findings}
\label{eval:unexpected}

\section{Outer applications}
\label{eval:outer-applications}

The \texttt{clerk} library allows to produce correct by construction spreadsheets.
I suppose that this property can make the library useful in real world systems.

First, this library can be used as a part of data pipelines.
The program using the \texttt{clerk} library can generate data-transforming spreadsheets.
There will be regions for input data, output data, and formulas.
The formulas will act onto input data to produce output data.
Other programs may write to or read the outputs from such data-transforming spreadsheets.

Second, such a library may be useful in areas that require correct computations.
As far as I know from Haskell community chats, some financial and biotechnological organizations rely on Haskell.
Moreover, some people use Excel for recording the results of scientific experiments.

Third, it is possible to use \texttt{clerk} for generating reports.
The library provides basic styling capabilities.
When the library is used with a Haskell repl, the resulting spreadsheets can be generated rapidly.
Thus, the spreadsheet editor may quickly observe the changes.

Fourth, the library may be used by pixel art fans.
It is quite trivial to fill the table cells with colors of pixels of an image.

Fifth, the library can be used for teaching type-level programming in Haskell.
More specifically, the library includes modules that provide type-level parsing capabilities.
These modules enable compile-time cell address and color values checks.

% \begin{longtable}{c|c}
% \caption[This is the title I want to appear in the List of Tables]{Simulation Parameters} \label{table:fifsimulation_params} \\
% \hline
% A & B  \\
% \hline
% \endfirsthead
% \multicolumn{2}{@{}l}{} \\
% \hline
% A & B \\
% \hline
% \endhead
% \hline
%  \textbf{Parameter} & \textbf{Value}\\
%  \hline
%  Number of vehicles & $|\mathcal{V}|$\\
%  \hline
%  Number of RSUs & $|\mathcal{U}|$\\
%  \hline
%  RSU coverage radius & 150 m\\
%  \hline
%  V2V communication radius & 30 m\\
%  \hline
%  Smart vehicle antenna height & 1.5 m\\
%  \hline
%  RSU antenna height & 25 m\\
%  \hline
%  Smart vehicle maximum speed & $v_{max}$ m/s\\
%  \hline
%  Smart vehicle minimum speed & $v_{min}$ m/s\\
%  \hline
%  Common smart vehicle cache capacities & $[50, 100, 150, 200, 250]$ mb\\
%  \hline
%  Common RSU cache capacities & $[5000,1000,1500,2000,2500]$ mb\\
%  \hline
%  Common backhaul rates & $[75, 100, 150]$ mb/s\\
%  \hline
% \end{longtable}

% \begin{figure}[hbt]
% \centering
% \includegraphics[]{figs/inno.png}
% \caption{One kernel at $x_s$ (\emph{dotted kernel}) or two kernels at
% $x_i$ and $x_j$ (\textit{left and right}) lead to the same summed estimate
% at $x_s$. This shows a figure consisting of different types of
% lines. Elements of the figure described in the caption should be set in
% italics, in parentheses, as shown in this sample caption.}
% \label{fig:fifex}
% \end{figure}

\ldots
