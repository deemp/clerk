
@article{thiemann_embedded_2005,
  title        = {An embedded domain-specific language for type-safe server-side web scripting},
  volume       = {5},
  issn         = {1533-5399, 1557-6051},
  url          = {https://dl.acm.org/doi/10.1145/1052934.1052935},
  doi          = {10.1145/1052934.1052935},
  abstract     = {{WASH}/{CGI} is an embedded domain-specific language for server-side Web scripting. Due to its reliance on the strongly typed, purely functional programming language Haskell as a host language, it is highly flexible and---at the same time---it provides extensive guarantees due to its pervasive use of type information.{WASH}/{CGI} can be structured into a number of sublanguages addressing different aspects of the application. The
                  document sublanguage
                  provides tools for the generation of parameterized {XHTML} documents and forms. Its typing guarantees that almost all generated documents are valid {XHTML} documents. The
                  session sublanguage
                  provides a session abstraction with a transparent notion of session state and allows the composition of documents and Web forms to entire interactive scripts. Both are integrated with the
                  widget sublanguage
                  which describes the communication (parameter passing) between client and server. It imposes a simple type discipline on the parameters that guarantees that forms posted by the client are always understood by the server. That is, the server never asks for data not submitted by the client and the data submitted by the client has the type requested by the server. In addition, parameters are received in their typed internal representation, not as strings. Finally, the
                  persistence sublanguage
                  deals with managing shared state on the server side as well as individual state on the client side. It presents shared state as an abstract data type, where the script can control whether it wants to observe mutations due to concurrently executing scripts. It guarantees that states from different interaction threads cannot be confused.},
  pages        = {1--46},
  number       = {1},
  journaltitle = {{ACM} Trans. Internet Technol.},
  author       = {Thiemann, Peter},
  urldate      = {2022-10-22},
  date         = {2005-02},
  langid       = {english}
}

@incollection{sano_hardware_2015,
  location   = {Cham},
  title      = {Hardware Synthesis from Functional Embedded Domain-Specific Languages: A Case Study in Regular Expression Compilation},
  volume     = {9040},
  isbn       = {978-3-319-16213-3 978-3-319-16214-0},
  url        = {http://link.springer.com/10.1007/978-3-319-16214-0_4},
  shorttitle = {Hardware Synthesis from Functional Embedded Domain-Specific Languages},
  abstract   = {Although {FPGAs} have the potential to bring software-like ﬂexibility and agility to the hardware world, designing for {FPGAs} remains a diﬃcult task divorced from standard software engineering norms. A better programming ﬂow would go far towards realizing the potential of widely deployed, programmable hardware. We propose a general methodology based on domain speciﬁc languages embedded in the functional language Haskell to bridge the gap between high level abstractions that support programmer productivity and the need for high performance in {FPGA} circuit implementations. We illustrate this methodology with a framework for regular expression to hardware compilers, written in Haskell, that supports high programmer productivity while producing circuits whose performance matches and, indeed, exceeds that of a state of the art, hand-optimized {VHDL}-based tool. For example, after applying a novel optimization pass, throughput increased an average of 28.3\% over the state of the art tool for one set of benchmarks. All code discussed in the paper is available online [1].},
  pages      = {41--52},
  booktitle  = {Applied Reconfigurable Computing},
  publisher  = {Springer International Publishing},
  author     = {Graves, Ian and Procter, Adam and Harrison, William L. and Becchi, Michela and Allwein, Gerard},
  editor     = {Sano, Kentaro and Soudris, Dimitrios and Hübner, Michael and Diniz, Pedro C.},
  urldate    = {2022-10-22},
  date       = {2015},
  langid     = {english},
  doi        = {10.1007/978-3-319-16214-0_4},
  note       = {Series Title: Lecture Notes in Computer Science}
}

@article{jones_experience_nodate,
  title    = {Experience Report: Playing the {DSL} Card},
  abstract = {This paper describes our experience using a functional language, Haskell, to build an embedded, domain-speciﬁc language ({DSL}) for component conﬁguration in large-scale, real-time, embedded systems. Prior to the introduction of the {DSL}, engineers would describe the steps needed to conﬁgure a particular system in a handwritten {XML} document. In this paper, we outline the application domain, give a brief overview of the {DSL} that we developed, and provide concrete data to demonstrate its effectiveness. In particular, we show that the {DSL} has several signiﬁcant beneﬁts over the original, {XML}-based approach including reduced code size, increased modularity and scalability, and detection and prevention of common defects. For example, using the {DSL}, we were able to produce clear and intuitive descriptions of component conﬁgurations that were sometimes less than 1/30 of the size of the original {XML}.},
  pages    = {4},
  author   = {Jones, Mark P},
  langid   = {english}
}

@article{anand_art_nodate,
  title    = {The Art of Interpretation for Domain-Speciﬁc Embedded Languages},
  abstract = {Domain-speciﬁc embedded language ({DSEL}) has become a convincing approach in managing the complexity of domain-speciﬁc applications. Its dependence on a host language enables domain experts to build programs at faster speed. Building {DSEL} on a host language with interpretive ability also provides a familiar calculator approach to domain experts, many of whom are programming novice. However, interpretive overhead can be a concern for the use of {DSEL}. In contrast with other research that investigates the compilation process of {DSEL}, we propose in this paper a framework for designing Haskell-based {DSEL} to attain eﬃciency in the interpretive environment. We lift the design of interpreter beyond the level of syntax-based interpretation, thus overcoming the notorious syntax-analysis problem with {DSEL}. One main technical contribution is the systematic and creative use of Haskell’s overloading mechanism to achieve domain-speciﬁc program analysis at interpretative time. In addition, we advocate the use of abstract data types, not just monadic computing, to achieve various domain-speciﬁc optimizations. We illustrate these features by designing a {DSEL} that supports technical analysis of ﬁnancial forecasting.},
  pages    = {13},
  author   = {Anand, Saswat and Khoo, Siau-Cheng and Xu, Dana N and Zhu, Ping},
  langid   = {english}
}

@article{leijen_domain_nodate,
  title  = {Domain Specific Embedded Compilers},
  pages  = {14},
  author = {Leijen, Daan and Meijer, Erik},
  langid = {english}
}

@inproceedings{valliappan_towards_2020,
  location   = {Virtual Event {USA}},
  title      = {Towards secure {IoT} programming in Haskell},
  isbn       = {978-1-4503-8050-8},
  url        = {https://dl.acm.org/doi/10.1145/3406088.3409027},
  doi        = {10.1145/3406088.3409027},
  abstract   = {{IoT} applications are often developed in programming languages with low-level abstractions, where a seemingly innocent mistake might lead to severe security vulnerabilities. Current {IoT} development tools make it hard to identify these vulnerabilities as they do not provide end-to-end guarantees about how data flows within and between appliances. In this work we present Haski, an embedded domain specific language ({eDSL}) in Haskell for secure programming of {IoT} devices. Haski enables developers to write Haskell programs that generate C code without falling into many of C’s pitfalls. Haski is designed after the synchronous programming language Lustre, and sports a backwards compatible information-flow control extension to restrict how sensitive data is propagated and modified within the application. We present a novel {eDSL} design which uses recursive monadic bindings and allows a natural use of functions and pattern matching to write embedded programs. To showcase Haski, we implement a simple smart house controller where communication is done via low-energy Bluetooth on the Zephyr {IoT} {OS}.},
  eventtitle = {{ICFP} '20: {ACM} {SIGPLAN} International Conference on Functional Programming},
  pages      = {136--150},
  booktitle  = {Proceedings of the 13th {ACM} {SIGPLAN} International Symposium on Haskell},
  publisher  = {{ACM}},
  author     = {Valliappan, Nachiappan and Krook, Robert and Russo, Alejandro and Claessen, Koen},
  urldate    = {2022-10-22},
  date       = {2020-08-27},
  langid     = {english}
}


@online{github_comonadsheet,
  title   = {Zotero {\textbar} Groups {\textgreater} thesis-spreadsheet},
  url     = {https://www.zotero.org/groups/4772792/thesis-spreadsheet},
  urldate = {2022-10-25}
}


@online{youtube_kudasov,
  title   = {Zotero {\textbar} Groups {\textgreater} thesis-spreadsheet},
  url     = {https://www.zotero.org/groups/4772792/thesis-spreadsheet},
  urldate = {2022-10-25}
}


@online{github_hcalc,
  title   = {Zotero {\textbar} Groups {\textgreater} thesis-spreadsheet},
  url     = {https://www.zotero.org/groups/4772792/thesis-spreadsheet},
  urldate = {2022-10-25}
}


@online{github_xlsx,
  title   = {Zotero {\textbar} Groups {\textgreater} thesis-spreadsheet},
  url     = {https://www.zotero.org/groups/4772792/thesis-spreadsheet},
  urldate = {2022-10-25}
}


@article{wakeling_spreadsheet_2007,
  title        = {Spreadsheet functional programming},
  volume       = {17},
  issn         = {0956-7968, 1469-7653},
  url          = {https://www.cambridge.org/core/product/identifier/S0956796806006186/type/journal_article},
  doi          = {10.1017/S0956796806006186},
  abstract     = {The functional programming community has shown some interest in spreadsheets, but surprisingly no one seems to have considered making a standard spreadsheet, such as Excel, work with a standard functional programming language, such as Haskell. In this paper, we show one way that this can be done. Our hope is that by doing so, we might get spreadsheet programmers to give functional programming a try.},
  pages        = {131--143},
  number       = {1},
  journaltitle = {J. Funct. Prog.},
  author       = {Wakeling, David},
  urldate      = {2022-10-22},
  date         = {2007-01},
  langid       = {english}
}


@inproceedings{mizzi_artagnan_2018,
  location   = {Vienna, Austria},
  title      = {D'Artagnan: An Embedded {DSL} Framework for Distributed Embedded Systems},
  isbn       = {978-1-4503-6355-6},
  url        = {http://dl.acm.org/citation.cfm?doid=3183895.3183899},
  doi        = {10.1145/3183895.3183899},
  shorttitle = {D'Artagnan},
  abstract   = {Programming distributed embedded systems gives rise to a number of challenges. The distributed nodes are typically resource constrained, requiring expert systems programming skills to manage the limited power, communication bandwidth, and memory and computation constraints. The challenge of raising the level of abstraction of programming such systems without incurring too high of an execution performance penalty is thus an important one, and many approaches have been explored in the literature.},
  eventtitle = {the Real World Domain Specific Languages Workshop 2018},
  pages      = {1--9},
  booktitle  = {Proceedings of the Real World Domain Specific Languages Workshop 2018 on - {RWDSL}2018},
  publisher  = {{ACM} Press},
  author     = {Mizzi, Adrian and Ellul, Joshua and Pace, Gordon},
  urldate    = {2022-10-22},
  date       = {2018},
  langid     = {english}
}

@inproceedings{ekblad_high-performance_2016,
  location   = {Nara Japan},
  title      = {High-performance client-side web applications through Haskell {EDSLs}},
  isbn       = {978-1-4503-4434-0},
  url        = {https://dl.acm.org/doi/10.1145/2976002.2976015},
  doi        = {10.1145/2976002.2976015},
  abstract   = {We present Aplite, a domain-speciﬁc language embedded in Haskell for implementing performance-critical functions in client-side web applications. In Aplite, we apply partial evaluation, multi-stage programming and techniques adapted from machine code-targeting, high-performance {EDSLs} to the domain of web applications. We use Aplite to implement, among other benchmarks, procedural animation using Perlin noise (Perlin 2002), symmetrical encryption and K-means clustering, showing Aplite to be consistently faster than equivalent hand-written {JavaScript} – up to an order of magnitude for some benchmarks. We also demonstrate how Aplite’s multi-staged nature can be used to automatically tune programs to the environment in which they are running, as well as to inputs representative of the programs’ intended workload. High-performance computation in the web browser is an attractive goal for many reasons: interactive simulations and games, cryptographic applications and reducing web companies’ electricity bills by outsourcing expensive computations to users’ web browsers. Similarly, functional programming in the browser is attractive due to its promises of simpler, shorter, safer programs. In this paper, we propose a way to combine the two.},
  eventtitle = {{ICFP}'16: {ACM} {SIGPLAN} International Conference on Functional Programming},
  pages      = {62--73},
  booktitle  = {Proceedings of the 9th International Symposium on Haskell},
  publisher  = {{ACM}},
  author     = {Ekblad, Anton},
  urldate    = {2022-10-22},
  date       = {2016-09-08},
  langid     = {english}
}

@inproceedings{svenningsson_simple_2013,
  location   = {Boston Massachusetts {USA}},
  title      = {Simple and compositional reification of monadic embedded languages},
  isbn       = {978-1-4503-2326-0},
  url        = {https://dl.acm.org/doi/10.1145/2500365.2500611},
  doi        = {10.1145/2500365.2500611},
  abstract   = {When writing embedded domain speciﬁc languages in Haskell, it is often convenient to be able to make an instance of the Monad class to take advantage of the do-notation and the extensive monad libraries. Commonly it is desirable to compile such languages rather than just interpret them. This introduces the problem of monad reiﬁcation, i.e. observing the structure of the monadic computation. We present a solution to the monad reiﬁcation problem and illustrate it with a small robot control language. Monad reiﬁcation is not new but the novelty of our approach is in its directness, simplicity and compositionality.},
  eventtitle = {{ICFP}'13: {ACM} {SIGPLAN} International Conference on Functional Programming},
  pages      = {299--304},
  booktitle  = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on Functional programming},
  publisher  = {{ACM}},
  author     = {Svenningsson, Josef David and Svensson, Bo Joel},
  urldate    = {2022-10-22},
  date       = {2013-09-25},
  langid     = {english}
}

@article{bernauer_eiger_2022,
  title        = {Eiger: Auditable, executable, flexible legal regulations},
  url          = {https://www.semanticscholar.org/reader/3532b1cd57aa2972f0bd7dd09698e98c4cccbdd0},
  doi          = {10.48550/arXiv.2209.04939},
  shorttitle   = {Eiger},
  abstract     = {An academic search engine that utilizes artificial intelligence methods to provide highly relevant results and novel tools to filter them with ease.},
  journaltitle = {undefined},
  author       = {Bernauer, Alexander and Eisenberg, R.},
  urldate      = {2022-10-22},
  date         = {2022},
  langid       = {english}
}

@article{hibino_experience_nodate,
  title    = {Experience Report: Haskell Relational Record},
  abstract = {{HaskellDB} is an embedded, domain-speciﬁc language that provides composability and type-safety for {SQL}. In spite of such excellent features, use of {HaskellDB} in real-world database operations discloses its drawbacks, including column name collisions and unclear semantics of aggregate queries. To solve these issues, we implemented Haskell Relational Record ({HRR}), which has support for outer joins and type-propagated placeholders as well as provides semantically-clear and conﬂict-free composability. {HRR} supports structured projections, which corresponds to nested, standard Haskell records. This paper describes the key ideas of {HRR} and reports on our experience developing and using it.},
  pages    = {6},
  author   = {Hibino, Kei and Murayama, Shohei and Yamamoto, Kazuhiko},
  langid   = {english}
}

@incollection{byrski_binderann_2020,
  location   = {Cham},
  title      = {{BinderAnn}: Automated Reification of Source Annotations for Monadic {EDSLs}},
  volume     = {12222},
  isbn       = {978-3-030-57760-5 978-3-030-57761-2},
  url        = {http://link.springer.com/10.1007/978-3-030-57761-2_2},
  shorttitle = {{BinderAnn}},
  abstract   = {Embedded Domain-Speciﬁc Languages ({EDSLs}) are an alternative to quickly implement specialized languages without the need to write compilers or interpreters from scratch. In this territory, Haskell is a prime choice as the host language. {EDSLs} in Haskell, however, are often incapable of reifying useful static information from the source code, namely variable binding names and source locations. Not having access to variable names directly aﬀects {EDSLs} designed to generate low-level code, where the variables names in the generated code do not match those found in the source code—thus broadening the semantic gap among source and target code. Similarly, many existing {EDSLs} produce poor error messages due to the lack of knowledge of source locations where errors are generated.},
  pages      = {25--46},
  booktitle  = {Trends in Functional Programming},
  publisher  = {Springer International Publishing},
  author     = {Mista, Agustín and Russo, Alejandro},
  editor     = {Byrski, Aleksander and Hughes, John},
  urldate    = {2022-10-22},
  date       = {2020},
  langid     = {english},
  doi        = {10.1007/978-3-030-57761-2_2},
  note       = {Series Title: Lecture Notes in Computer Science}
}

@article{shibata_hook_nodate,
  title    = {Hook: An Embedded Domain-Specific Language for Fusing Implicit Interactions to Explicit Event Handlers},
  abstract = {Emerging physiological sensing technologies are leading to an interaction design paradigm—namely implicit interactions—in which computers have the ability to implicitly perceive and respond to the physiological understandings of their users. However, a noticeable challenge remains in integrating such implicit interactions into a conventional event-based interactive system, which typically responds to the user’s explicit events. (e.g., key presses, mouse clicks, etc.) The challenge is due to multiple input sources of different types, and, by extension, demands programmers to be responsible for prescribing how interactions of the two different types, implicit and explicit, interfere with each other. To address this challenge, we introduce a domain-specific language ({DSL}), Hook, that allows programmers to declaratively express when to perform implicit interactions with respect to desired explicit ones and how to fuse the computational effects of the interactions in a modular way. The Hook language treats interactions as a first-class abstraction and provides three types of fusion strategies, which assist programmers in gluing the two types of interactions together. This paper describes an implementation of the Hook language as a {DSL} embedded in Haskell and formalizes the language as a computational model for future replication and extension. We also demonstrate the utility of the language through three case studies, each of which implements an implicit interaction that extends behaviors of a published interactive system. Lastly, we discuss limitations of the language in its current state and how the language could further aid programmers to achieve separation of concerns while maintaining algorithmic precision in implementing a complex combination of different types of interactions. {CCS} Concepts: • Human-centered computing → Human computer interaction ({HCI}); Systems and tools for interaction design; • Software and its engineering → Domain specific languages.},
  pages    = {30},
  author   = {Shibata, Tomoki and Ahrens, Matthew and Jacob, Robert J K},
  langid   = {english}
}

@misc{evans_circuitflow_2021,
  title      = {{CircuitFlow}: A Domain Specific Language for Dataflow Programming (with appendices)},
  url        = {http://arxiv.org/abs/2111.12420},
  shorttitle = {{CircuitFlow}},
  abstract   = {Dataﬂow applications, such as machine learning algorithms, can run for days, making it desirable to have assurances that they will work correctly. Current tools are not good enough: too often the interactions between tasks are not type-safe, leading to undesirable runtime errors. This paper presents a new declarative Haskell Embedded {DSL} ({eDSL}) for dataﬂow programming: {CircuitFlow}. Deﬁned as a Symmetric Monoidal Preorder ({SMP}) on data that models dependencies in the workﬂow, it has a strong mathematical basis, refocusing on how data ﬂows through an application, resulting in a more expressive solution that not only catches errors statically, but also achieves competitive run-time performance. In our preliminary evaluation, {CircuitFlow} outperforms the industry-leading Luigi library of Spotify by scaling better with the number of inputs. The innovative creation of {CircuitFlow} is also of note, exemplifying how to create a modular {eDSL} whose semantics necessitates eﬀects, and where storing complex type information for program correctness is paramount.},
  number     = {{arXiv}:2111.12420},
  publisher  = {{arXiv}},
  author     = {Evans, Riley and Frohlich, Samantha and Wang, Meng},
  urldate    = {2022-10-22},
  date       = {2021-11-24},
  langid     = {english},
  eprinttype = {arxiv},
  eprint     = {2111.12420 [cs]},
  keywords   = {Computer Science - Programming Languages}
}

@inproceedings{perera_transformation_2020,
  location   = {Colombo, Sri Lanka},
  title      = {Transformation of Contract Descriptions in a Domain Specific Language to Solidity Assembly},
  isbn       = {978-1-72818-655-9},
  url        = {https://ieeexplore.ieee.org/document/9325490/},
  doi        = {10.1109/ICTer51097.2020.9325490},
  eventtitle = {2020 20th International Conference on Advances in {ICT} for Emerging Regions ({ICTer})},
  pages      = {89--94},
  booktitle  = {2020 20th International Conference on Advances in {ICT} for Emerging Regions ({ICTer})},
  publisher  = {{IEEE}},
  author     = {Perera, K.S.M. and Gunawardana, K. G. and Keppitiyagama, C. I.},
  urldate    = {2022-10-22},
  date       = {2020-11-04}
}

@inproceedings{viera_staged_2018,
  location   = {Lowell {MA} {USA}},
  title      = {A Staged Embedding of Attribute Grammars in Haskell},
  isbn       = {978-1-4503-7143-8},
  url        = {https://dl.acm.org/doi/10.1145/3310232.3310235},
  doi        = {10.1145/3310232.3310235},
  abstract   = {In this paper, we present an embedding of attribute grammars in Haskell, that is both modular and type-safe, while providing the user with domain specific error messages. Our approach involves to delay part of the safety checks to runtime. When a grammar is correct, we are able to extract a function that can be run without expecting any runtime error related to the {EDSL}.},
  eventtitle = {{IFL} 2018: 30th Symposium on Implementation and Application of Functional Languages},
  pages      = {95--106},
  booktitle  = {Proceedings of the 30th Symposium on Implementation and Application of Functional Languages},
  publisher  = {{ACM}},
  author     = {Viera, Marcos and Balestrieri, Florent and Pardo, Alberto},
  urldate    = {2022-10-22},
  date       = {2018-09-05},
  langid     = {english}
}

@incollection{morales_adding_2021,
  location  = {Cham},
  title     = {On Adding Pattern Matching to Haskell-Based Deeply Embedded Domain Specific Languages},
  volume    = {12548},
  isbn      = {978-3-030-67437-3 978-3-030-67438-0},
  url       = {http://link.springer.com/10.1007/978-3-030-67438-0_2},
  abstract  = {Capturing control ﬂow is the Achilles heel of Haskell-based deeply embedded domain speciﬁc languages. Rather than use the builtin control ﬂow mechanisms, artiﬁcial control ﬂow combinators are used instead. However, capturing traditional control ﬂow in a deeply embedded domain speciﬁc language would support the writing of programs in a natural style by allowing the programmer to use the constructs that are already builtin to the base language, such as pattern matching and recursion. In this paper, we expand the capabilities of Haskell-based deep embeddings with a compiler extension for reifying conditionals and pattern matching. With this new support, the subset of Haskell that we use for expressing deeply embedded domain speciﬁc languages can be cleaner, Haskell-idiomatic, and more declarative in nature.},
  pages     = {20--36},
  booktitle = {Practical Aspects of Declarative Languages},
  publisher = {Springer International Publishing},
  author    = {Young, David and Grebe, Mark and Gill, Andy},
  editor    = {Morales, José F. and Orchard, Dominic},
  urldate   = {2022-10-22},
  date      = {2021},
  langid    = {english},
  doi       = {10.1007/978-3-030-67438-0_2},
  note      = {Series Title: Lecture Notes in Computer Science}
}

@inproceedings{mcdonell_embedded_2022,
  location   = {Ljubljana Slovenia},
  title      = {Embedded pattern matching},
  isbn       = {978-1-4503-9438-3},
  url        = {https://dl.acm.org/doi/10.1145/3546189.3549917},
  doi        = {10.1145/3546189.3549917},
  abstract   = {Haskell is a popular choice for hosting deeply embedded languages. A recurring challenge for these embeddings is how to seamlessly integrate user defined algebraic data types. In particular, one important, convenient, and expressive feature for creating and inspecting {dataÐpattern} {matchingÐis} not directly available on embedded terms. We present a novel technique, embedded pattern matching, which enables a natural and user friendly embedding of user defined algebraic data types into the embedded language, and allows programmers to pattern match on terms in the embedded language in much the same way they would in the host language.},
  eventtitle = {Haskell '22: 15th {ACM} {SIGPLAN} International Haskell Symposium},
  pages      = {123--136},
  booktitle  = {Proceedings of the 15th {ACM} {SIGPLAN} International Haskell Symposium},
  publisher  = {{ACM}},
  author     = {{McDonell}, Trevor L. and Meredith, Joshua D. and Keller, Gabriele},
  urldate    = {2022-10-22},
  date       = {2022-09-06},
  langid     = {english}
}

@incollection{hutchison_optimising_2004,
  location    = {Berlin, Heidelberg},
  title       = {Optimising Embedded {DSLs} Using Template Haskell},
  volume      = {3286},
  isbn        = {978-3-540-23580-4 978-3-540-30175-2},
  url         = {http://link.springer.com/10.1007/978-3-540-30175-2_10},
  abstract    = {Embedded domain speciﬁc languages ({EDSLs}) provide a specialised language for a particular application area while harnessing the infrastructure of an existing general purpose programming language. The reduction in implementation costs that results from this approach comes at a price: the {EDSL} often compiles to ineﬃcient code since the host language’s compiler only optimises at the level of host language constructs. The paper presents an approach to solving this problem based on compile-time meta-programming which retains the simplicity of the embedded approach. We use {PanTHeon}, our implementation of an existing {EDSL} for image synthesis to demonstrate the beneﬁts and drawbacks of this approach. Furthermore, we suggest potential improvements to Template Haskell, the meta-programming framework we are using, which would greatly improve its applicability to this kind of task.},
  pages       = {186--205},
  booktitle   = {Generative Programming and Component Engineering},
  publisher   = {Springer Berlin Heidelberg},
  author      = {Seefried, Sean and Chakravarty, Manuel and Keller, Gabriele},
  editor      = {Karsai, Gabor and Visser, Eelco},
  editorb     = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard},
  editorbtype = {redactor},
  urldate     = {2022-10-22},
  date        = {2004},
  langid      = {english},
  doi         = {10.1007/978-3-540-30175-2_10},
  note        = {Series Title: Lecture Notes in Computer Science}
}

@inproceedings{garcia-garland_attribute_2019,
  location   = {Singapore Singapore},
  title      = {Attribute grammars fly first-class... safer!: dealing with {DSL} errors in type-level programming},
  isbn       = {978-1-4503-7562-7},
  url        = {https://dl.acm.org/doi/10.1145/3412932.3412942},
  doi        = {10.1145/3412932.3412942},
  shorttitle = {Attribute grammars fly first-class... safer!},
  abstract   = {{AspectAG} is a domain specific language embedded in Haskell to represent modular attribute grammars. In {AspectAG} attribute grammar fragments can be defined independently (even in separate modules) and then combined in a safe way. This flexibility is achieved through the use of extensible records, which are implemented using type-level programming techniques.},
  eventtitle = {{IFL} '19: Implementation and Application of Functional Languages},
  pages      = {1--12},
  booktitle  = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
  publisher  = {{ACM}},
  author     = {García-Garland, Juan and Pardo, Alberto and Viera, Marcos},
  urldate    = {2022-10-22},
  date       = {2019-09-25},
  langid     = {english}
}

@article{caruana_embedded_nodate,
  title    = {Embedded Languages for Origami-Based Geometry},
  abstract = {Embedded languages have been used to support compositional descriptions for various domains. In this paper, we look at the domain of paper folding, or Origami-based geometry, in which sequences of paper folding are used to describe points and lines on the plane. Based on seven basic origami axioms, we design and develop an embedded domain speciﬁc language for the descriptions of such constructions in Haskell. We argue that the embedded language approach, that is composing a model using the basic constructors in the domain speciﬁc language, gives a compositional and concise way to describe Origami models. We look into analysis, manipulation and generation of origami models using this approach, including textual explanations of models, analysis of models to discover inherent preconditions (or constraints) in a description and basic animation of the folding of a model. Finally, we look into the tagging of blocks within a construction, enabling diﬀerent evaluations at various levels of abstraction according to the user’s knowledge of Origami.},
  pages    = {11},
  author   = {Caruana, Gaetano and Pace, Gordon J},
  langid   = {english}
}

@inproceedings{grebe_rewriting_2017,
  location   = {Vancouver {BC} Canada},
  title      = {Rewriting a shallow {DSL} using a {GHC} compiler extension},
  isbn       = {978-1-4503-5524-7},
  url        = {https://dl.acm.org/doi/10.1145/3136040.3136048},
  doi        = {10.1145/3136040.3136048},
  abstract   = {Embedded Domain Specific Languages are a powerful tool for developing customized languages to fit specific problem domains. Shallow {EDSLs} allow a programmer to program using many of the features of a host language and its syntax, but sacrifice performance. Deep {EDSLs} provide better performance and flexibility, through the ability to manipulate the abstract syntax tree of the {DSL} program, but sacrifice syntactical similarity to the host language. Using Haskino, an {EDSL} designed for small embedded systems based on the Arduino line of microcontrollers, and a compiler plugin for the Haskell {GHC} compiler, we show a method for combining the best aspects of shallow and deep {EDSLs}. The programmer is able to write in the shallow {EDSL}, and have it automatically transformed into the deep {EDSL}. This allows the {EDSL} user to benefit from powerful aspects of the host language, Haskell, while meeting the demanding resource constraints of the small embedded processing environment.},
  eventtitle = {{SPLASH} '17: Conference on Systems, Programming, Languages, and Applications: Software for Humanity},
  pages      = {246--258},
  booktitle  = {Proceedings of the 16th {ACM} {SIGPLAN} International Conference on Generative Programming: Concepts and Experiences},
  publisher  = {{ACM}},
  author     = {Grebe, Mark and Young, David and Gill, Andy},
  urldate    = {2022-10-22},
  date       = {2017-10-23},
  langid     = {english}
}

@incollection{russo_environment_2012,
  location   = {Berlin, Heidelberg},
  title      = {The Environment as an Argument: Context-Aware Functional Programming},
  volume     = {7149},
  isbn       = {978-3-642-27693-4 978-3-642-27694-1},
  url        = {http://link.springer.com/10.1007/978-3-642-27694-1_5},
  shorttitle = {The Environment as an Argument},
  abstract   = {Context-awareness as deﬁned in the setting of Ubiquitous Computing [3] is all about expressing the dependency of a speciﬁc computation upon some implicit piece of information. The manipulation and expression of such dependencies may thus be neatly encapsulated in a language where computations are ﬁrst-class values. Perhaps surprisingly however, context-aware programming has not been explored in a functional setting, where ﬁrst-class computations and higher-order functions are commonplace. In this paper we present an embedded domain-speciﬁc language ({EDSL}) for constructing context-aware applications in the functional programming language Haskell.},
  pages      = {48--62},
  booktitle  = {Practical Aspects of Declarative Languages},
  publisher  = {Springer Berlin Heidelberg},
  author     = {Martins, Pedro M. and {McCann}, Julie A. and Eisenbach, Susan},
  editor     = {Russo, Claudio and Zhou, Neng-Fa},
  urldate    = {2022-10-22},
  date       = {2012},
  langid     = {english},
  doi        = {10.1007/978-3-642-27694-1_5},
  note       = {Series Title: Lecture Notes in Computer Science}
}

@article{brule_whittemore_2018,
  title        = {Whittemore: An embedded domain specific language for causal programming},
  url          = {https://www.semanticscholar.org/reader/500871726f9d215b66088e860e6983f0c83e2d63},
  shorttitle   = {Whittemore},
  abstract     = {An academic search engine that utilizes artificial intelligence methods to provide highly relevant results and novel tools to filter them with ease.},
  journaltitle = {undefined},
  author       = {Brulé, Joshua},
  urldate      = {2022-10-22},
  date         = {2018},
  langid       = {english}
}

@article{bedo_bioshake_2019,
  title        = {{BioShake}: a Haskell {EDSL} for bioinformatics workflows},
  volume       = {7},
  url          = {https://www.readcube.com/articles/10.7717%2Fpeerj.7223},
  doi          = {10.7717/peerj.7223},
  shorttitle   = {{BioShake}},
  abstract     = {Typical bioinformatics analyses comprise of long running computational workflows. An important part of reproducible research is the management and execution of these workflows to allow robust execution and to minimise errors. {BioShake} is an embedded domain specific language in Haskell for specifying and executing computational workflows for bioinformatics that significantly reduces the possibility of errors occurring. Unlike other workflow frameworks, {BioShake} raises many properties to the type level allowing the correctness of a workflow to be statically checked during compilation, catching errors before any lengthy execution process. {BioShake} builds on the Shake build tool to provide robust dependency tracking, parallel execution, reporting, and resumption capabilities. Finally, {BioShake} abstracts execution so that jobs can either be executed directly or submitted to a cluster. {BioShake} is available at http://github.com/{PapenfussLab}/bioshake.},
  journaltitle = {{PeerJ}},
  author       = {Bedő, Justin},
  urldate      = {2022-10-22},
  date         = {2019},
  langid       = {english}
}


@online{noauthor_semantic_nodate,
  title    = {Semantic Scholar {\textbar} {AI}-Powered Research Tool},
  url      = {https://www.semanticscholar.org/},
  abstract = {Semantic Scholar uses groundbreaking {AI} and engineering to understand the semantics of scientific literature to help Scholars discover relevant research.},
  urldate  = {2022-10-25},
  langid   = {english}
}


@online{noauthor_google_nodate,
  title   = {Google Scholar},
  url     = {https://scholar.google.com/?hl=en&as_sdt=0,5},
  urldate = {2022-10-25}
}

@online{noauthor_packages_nodate,
  title   = {packages by category {\textbar} Hackage},
  url     = {https://hackage.haskell.org/packages/},
  urldate = {2022-10-25}
}

@online{noauthor_haskellwiki_nodate,
  title   = {{HaskellWiki}},
  url     = {https://wiki.haskell.org/Haskell},
  urldate = {2022-10-25}
}

@online{noauthor_build_nodate,
  title      = {Build software better, together},
  url        = {https://github.com},
  abstract   = {{GitHub} is where people build software. More than 83 million people use {GitHub} to discover, fork, and contribute to over 200 million projects.},
  titleaddon = {{GitHub}},
  urldate    = {2022-10-25},
  langid     = {english}
}

@online{noauthor_google_nodate-1,
  title   = {Google},
  url     = {https://www.google.com/?hl=en},
  urldate = {2022-10-25}
}

@online{noauthor_zotero_nodate,
  title   = {Zotero {\textbar} Groups {\textgreater} thesis-spreadsheet},
  url     = {https://www.zotero.org/groups/4772792/thesis-spreadsheet},
  urldate = {2022-10-25}
}


@online{hackage_clerk_2023,
  title      = {clerk},
  url        = {https://hackage.haskell.org/package/clerk},
  abstract   = {Declaratively describe spreadsheets},
  titleaddon = {Hackage},
  urldate    = {2023-05-19}
}

@software{danko_clerk_2023,
  title    = {clerk},
  rights   = {{BSD}-3-Clause},
  url      = {https://github.com/deemp/clerk},
  abstract = {Declaratively generate spreadsheets},
  author   = {Danko, Danila},
  urldate  = {2023-05-19},
  date     = {2023-03-29},
  note     = {original-date: 2022-12-26T16:42:25Z}
}


@online{excel_lambda,
  title   = {{LAMBDA} function - Microsoft Support},
  url     = {https://support.microsoft.com/en-us/office/lambda-function-bd212d27-1cd1-4321-a34a-ccbf254b8b67},
  urldate = {2023-05-19}
}

@online{excel_custom_types,
  title   = {Create a data type (Power Query) - Microsoft Support},
  url     = {https://support.microsoft.com/en-us/office/create-a-data-type-power-query-a465a3b7-3d37-4eb1-a59c-bd3163315308},
  urldate = {2023-05-19}
}

@online{sheets_lambda,
  title   = {{LAMBDA} function - Google Docs Editors Help},
  url     = {https://support.google.com/docs/answer/12508718?hl=en},
  urldate = {2023-05-19}
}


@software{wang_poi_nodate,
  title      = {poi: Write Excel {XLSX} declaratively.},
  rights     = {{MIT} License},
  url        = {https://github.com/baoshishu/poi},
  shorttitle = {poi},
  version    = {1.0.1},
  author     = {Wang, Ryan},
  urldate    = {2023-05-19},
  keywords   = {declarative, excel,, Software Development - Libraries, Software Development - Libraries - Python Modules, xlswriter,, xlsx,}
}


@online{noauthor_sikrinickgeshikt_nodate,
  title      = {sikrinick/geshikt at androidexample365.com},
  url        = {https://github.com/sikrinick/geshikt},
  abstract   = {Geshikt is a declarative {API} to set up spreadsheets and sheets in Google Sheets.  - sikrinick/geshikt at androidexample365.com},
  titleaddon = {{GitHub}},
  urldate    = {2023-05-19},
  langid     = {english}
}
